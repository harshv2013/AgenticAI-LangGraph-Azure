# # data_analysis_agents/executor.py
# import subprocess
# import tempfile
# import os
# import json
# import shlex
# from pathlib import Path

# def execute_code(state):
#     """
#     state contains:
#       - 'code' (string) generated by codegen
#       - 'file_path' original dataset path to pass to code or script can reference it
#     Runs the code in a subprocess, returns {'status','stdout','stderr','charts': [...], 'insights':[...] }
#     """
#     code = state.get("code", "")
#     if not code:
#         return {"error": "No code to run."}

#     # write to temp file
#     tmp_dir = Path(".").resolve()
#     # ensure deterministic filenames in working dir for UI pickup
#     script_file = tmp_dir / "agentic_analysis_script.py"

#     with open(script_file, "w", encoding="utf-8") as f:
#         f.write(code)

#     # Prepare a safe env: copy only minimal PATH, but remove network keys
#     safe_env = os.environ.copy()
#     for k in list(safe_env.keys()):
#         if "AWS" in k or "AZURE" in k or "OPENAI" in k or "TAVILY" in k:
#             safe_env.pop(k, None)

#     # Force matplotlib to use Agg in case script didn't
#     safe_env["MPLBACKEND"] = "Agg"

#     try:
#         # Run script (python interpreter same as current)
#         # subprocess will block; choose a conservative timeout
#         # proc = subprocess.run(
#         #     [shlex.quote(os.sys.executable), str(script_file)],
#         #     capture_output=True,
#         #     text=True,
#         #     env=safe_env,
#         #     timeout=20
#         # )
#         proc = subprocess.run(
#             [os.sys.executable, str(script_file)],
#             capture_output=True,
#             text=True,
#             env=safe_env,
#             timeout=20,
#             shell=False  # important for Windows; don't use shell=True here
#         )
#     except subprocess.TimeoutExpired as e:
#         return {"status": "timeout", "error": str(e)}

#     stdout = proc.stdout or ""
#     stderr = proc.stderr or ""

#     # Try to parse last JSON object in stdout (script prints JSON at end)
#     parsed = {}
#     insights = []
#     charts = {}

#     try:
#         # find last line that looks like JSON
#         last_lines = [l for l in stdout.splitlines() if l.strip()]
#         if last_lines:
#             last = last_lines[-1]
#             parsed = json.loads(last)
#             # parsed expected to have keys 'insights' and 'charts'
#             insights = parsed.get("insights", [])
#             chart_list = parsed.get("charts", [])
#             # convert to dict (name->path) if needed
#             for p in chart_list:
#                 charts[Path(p).name] = str((tmp_dir / Path(p)).resolve())
#     except Exception:
#         # parsing failed â€” include stdout for debugging
#         parsed = {"raw_stdout": stdout}

#     result = {
#         "status": "executed",
#         "stdout": stdout,
#         "stderr": stderr,
#         "parsed": parsed,
#         "insights": insights,
#         "charts": charts
#     }

#     return result




# data_analysis_agents/executor.py
import subprocess
import os
import json
from pathlib import Path
import ast

def execute_code(state):
    """
    state contains:
      - 'code' (string) generated by codegen
      - 'file_path' original dataset path (to inject into code if missing)
    Runs the code in a subprocess, returns {'status','stdout','stderr','charts': [...], 'insights':[...] }
    """
    code = state.get("code", "")
    file_path = state.get("file_path", "")

    if not code:
        return {"error": "No code to run."}

    # Strip Markdown code fences if present (``` or ```python)
    if code.strip().startswith("```"):
        code = code.strip()
        code = code.replace("```python", "").replace("```", "").strip()

    # Inject CSV path if model left it as "None"
    if '"None"' in code and file_path:
        print(f"Injecting CSV path: {file_path}")
        code = code.replace('"None"', f'"{file_path}"')

    # Validate Python syntax before writing
    try:
        ast.parse(code)
    except SyntaxError as e:
        return {
            "status": "error",
            "error": f"Generated code is invalid Python: {e}",
            "stdout": "",
            "stderr": "",
            "insights": [],
            "charts": {}
        }

    # Write to a consistent file for visibility
    tmp_dir = Path(".").resolve()
    script_file = tmp_dir / "agentic_analysis_script.py"

    with open(script_file, "w", encoding="utf-8") as f:
        f.write(code)

    # Prepare a safe environment (remove sensitive cloud keys)
    safe_env = os.environ.copy()
    for k in list(safe_env.keys()):
        if any(service in k for service in ["AWS", "AZURE", "OPENAI", "TAVILY"]):
            safe_env.pop(k, None)

    # Force matplotlib to non-GUI backend
    safe_env["MPLBACKEND"] = "Agg"

    try:
        proc = subprocess.run(
            [os.sys.executable, str(script_file)],
            capture_output=True,
            text=True,
            env=safe_env,
            timeout=25,
            shell=False
        )
    except subprocess.TimeoutExpired as e:
        return {"status": "timeout", "error": str(e)}

    stdout = proc.stdout or ""
    stderr = proc.stderr or ""

    # Parse last JSON line from stdout
    # parsed = {}
    # insights = []
    # charts = {}

    # try:
    #     last_lines = [l for l in stdout.splitlines() if l.strip()]
    #     if last_lines:
    #         last = last_lines[-1]
    #         parsed = json.loads(last)
    #         insights = parsed.get("insights", [])
    #         chart_list = parsed.get("charts", [])
    #         for p in chart_list:
    #             charts[Path(p).name] = str((tmp_dir / Path(p)).resolve())
    # except Exception:
    #     parsed = {"raw_stdout": stdout}

        # Parse JSON block from stdout (even if pretty-printed)
    parsed = {}
    insights = []
    charts = {}

    try:
        json_text = stdout.strip()

        # Extract JSON even if it's formatted with newlines
        start_idx = json_text.find("{")
        end_idx = json_text.rfind("}")
        if start_idx != -1 and end_idx != -1:
            json_str = json_text[start_idx:end_idx+1]
            parsed = json.loads(json_str)
            insights = parsed.get("insights", [])
            chart_list = parsed.get("charts", [])
            for p in chart_list:
                charts[Path(p).name] = str((tmp_dir / Path(p)).resolve())
        else:
            parsed = {"raw_stdout": stdout}
    except Exception as e:
        parsed = {"error": f"Failed to parse JSON: {e}", "raw_stdout": stdout}


    result = {
        "status": "executed",
        "stdout": stdout,
        "stderr": stderr,
        "parsed": parsed,
        "insights": insights,
        "charts": charts
    }

    print(f"Executor finished. Insights: {len(insights)}, Charts: {len(charts)}, Errors: {parsed.get('errors', [])}")
    return result

